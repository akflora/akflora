#!/bin/gawk -f

# Looks for names from list A ("Query set") in list B ("Master set")
# Matching them at different "quality levels", and optionally doing fuzzy
# matching using agrep

# (c) Cam Webb, 2018
# Licence: Public Domain (Via: https://unlicense.org/)

## Dependencies:
# 1. GNU gawk v.4+
# 2. Set $AWKPATH to find function libraries (depunct.awk)
# 3. agrep (https://laurikari.net/tre/)

## Conventions:
# Variables shared among functions and main begin with Capital letters

@include "depunct.awk"

BEGIN{
  config()
  read_args()
  
  ## Read reference names
  read_data(Bfile)

  # make sublists, for agrep
  if (FUZZY) make_agrep_lists(Bfile)

  ## Read query names
  read_data(Afile)

  ## Main loop though the lines of input file A
  for (line = 1; line <= Lines[Afile]; line++) {
    ac = C[Afile, line]
    
    if      (test_eq("exact",   ac)) continue
    else if (test_eq("punct",   ac)) continue
    else if (test_pm("basio",   ac)) continue
    else if (test_pm("exin",    ac)) continue
    else if (test_pm("basexin", ac)) continue
    else if (test_pm("basexin", ac)) continue
    else if (Auct[ac]) no_match(ac)
    else if (FUZZY && GL[G[ac]]) fuzzy(ac, line)
    else no_match(ac)
  }

  clean_exit(1)
}

function config() {
  ## Config
  FS = "|"
  OFS= "|"
  PROCINFO["sorted_in"] =  "@ind_str_asc"
  FUZZERR = 5

  # Column order; same in both files
  I_code = 1 ; I_xg = 2  ; I_g = 3  ; I_xs = 4 ; I_s = 5
  I_st = 6   ; I_ssp = 7 ; I_a = 8 
}

function read_args(    arg) {
  ## Read arguments and fail-to usage 
  for (arg = 1; arg < ARGC; arg++) {
    if      (ARGV[arg] == "-a") Afile = ARGV[arg+1]
    else if (ARGV[arg] == "-b") Bfile = ARGV[arg+1]
    else if (ARGV[arg] == "-o") OUTFILE  = ARGV[arg+1]
    else if (ARGV[arg] == "-f") FUZZY    = 1
    else if (ARGV[arg] == "-e") FUZZERR  = ARGV[arg+1]
  }
  if (!Afile || !Bfile || !OUTFILE || ARGC == 1) {
    print "usage:    match_names -a query_names_file -b " \
      "ref_names_file -n outfile [-f [-e fuzz_error]]"
    exit 1
  }

  ## Delete existing OUTFILE
  system("rm -f " OUTFILE)
}


function read_data(filename,     i, nameN, namex) {
  
  while ((getline < filename) > 0) {
    # clean Data of spaces and NULL symbols
    for (i = 1; i <= NF; i++) {
      gsub(/^(NULL|\\N)$/,"",$i)
      $i = cleanspaces($i)
    }

    # lines
    C[filename, ++Lines[filename]] = $I_code
    
    # check for duplicate code
    if (++CodeN[$I_code] > 1) {
      print "Code '" $I_code "' is a duplicate..."
      exit 1
    }

    # For output and loading into DB
    Data[$I_code] = $I_xg OFS $I_g OFS $I_xs OFS $I_s OFS \
      $I_st OFS $I_ssp OFS $I_a
    
    # "exact" string for manual string matching
    X[filename, "exact", $I_code] = cleanspaces($I_xg " " $I_g " " $I_xs " "  \
           $I_s " " $I_st " " $I_ssp " " $I_a)
    XC[filename, "exact", X[filename, "exact", $I_code]] = $I_code
    # Check for duplicate name
    if (++nameN[X[filename, "exact", $I_code]] > 1) {
      print "Error: file " filename ", name '" X[filename, "exact", $I_code] \
        "' is a duplicate..."
      exit 1
    }
    
    ## Keys:
    namex = $I_xg $I_g $I_xs $I_s $I_st $I_ssp

    # NB: using computed regex here, less efficient, but tidier code
    # plain depunct
    apply_regex(filename, $I_code, namex, $I_a, "punct", "") ;
    # depunct, with basionym removed
    apply_regex(filename, $I_code, namex, $I_a, "basio", "^\\([^)]+\\)") ;
    # depunct with 'ex' or 'in' removed
    apply_regex(filename, $I_code, namex, $I_a, "exin", "\\ (ex|in)\\ .*$") ;
    # depunct with basio and 'ex' or 'in' removed
    apply_regex(filename, $I_code, namex, $I_a, "basexin", \
                "(^\\([^)]+\\)|\\ (ex|in)\\ .*$)")
    # auct?
    if ($I_a ~ /^auct\.?$/) Auct[$I_code] = 1
    # genus list
    G[$I_code] = $I_g
  }
}

function make_agrep_lists(filename,    cmd, i) {
  cmd = "mktemp -d"
  cmd | getline TEMPDIR
  # only B names, so far:
  for (i in CodeN) {
    print i " " X[filename, "punct", i]  >> TEMPDIR "/" G[i]
    close(TEMPDIR "/" G[i])
    # variable to track which genera are in the TEMPDIR:
    GL[G[i]]++;
  }
}

function test_eq(method, code,      outmethod) {
  
  outmethod = method == "punct" ? "auto_punct" : method
  # if there is a B code for the A key, using the same method
  if (XC[Bfile, method, X[Afile, method, code]]) {
    print code, XC[Bfile, method, X[Afile, method, code]],    \
      outmethod , Data[code] ,                            \
      Data[XC[Bfile, method, X[Afile, method, code]]] >> OUTFILE
    close(OUTFILE)
    return 1
  }
  else return 0
}

function test_pm(method, code) {

  #^ print X[Afile, "punct", code], XC[Bfile, method, X[Afile, "punct", code]]
  # if there is a B code for the collapsed A key
  if (XC[Bfile, method, X[Afile, "punct", code]]) {
    print code, XC[Bfile, method, X[Afile, "punct", code]],  \
      "auto_" method "-" , Data[code] ,                                 \
      Data[XC[Bfile, method, X[Afile, "punct", code]]] >> OUTFILE
    close(OUTFILE)
    return 1
  }
  
  # if there is a collapse B code for the A key
  else if (XC[Bfile, "punct", X[Afile, method, code]]) {
    print code, XC[Bfile, "punct", X[Afile, method, code]],  \
      "auto_" method "+" , Data[code] ,                            \
      Data[XC[Bfile, "punct", X[Afile, method, code]]] >> OUTFILE
    close(OUTFILE)
    return 1
  }
  else return 0
}

function apply_regex(AB, code, name, auth, method, regex) {

  gsub(regex, "", auth)
  X[AB, method, code] = depunct(name auth)
  XC[AB, method, X[AB, method, code]] = code
  # check for possible duplicate keys. The used match will be the first one
  if (++XN[AB, method, X[AB, method, code]] > 1) {
    print "Warning: " code  \
        " has duplicate " method " form:\n           "  X[AB, method, code]
    for (i in CodeN)
      if ((X[AB, method, i] == X[AB, method, code]) && (i != code))
        print "   with: " i 
  }
}

function cleanspaces(x) {
  # X is an external variable
  gsub(/\ \ */," ", x)
  gsub(/\ *$/, "" , x)
  gsub(/^\ */, "" , x)
  return x
}

function no_match(code) {
  print code "||no_match|" X[Afile, "exact", code] "|||||||||||||" \
        >> OUTFILE
  close(OUTFILE)
}

function clean_exit(status) {
  system("rm -rf "TEMPDIR)
  exit status
}

function fuzzy(code, lineno,    cmd, agreps, na, a, b, j, code_of_j, r) {
  
  # send depunct A name to agrep
  # Note, a genus spelling mismatch will not be found due to
  #   wrong temporary genus name list
  cmd = "agrep -w -k -" FUZZERR " \"" X[Afile, "punct", code] "\" " \
    TEMPDIR "/" G[code] " | sort -k 2"
  agreps = ""
  RS = "\x04" 
  cmd | getline agreps
  close(cmd)
  RS = "\n" # needed for interactive input
  gsub(/\n$/,"", agreps) # to remove 'default' newline

  # If there was an agrep match, list match(s)
  if (length(agreps)) {
    na = split(agreps, a, "\n")
    printf "---------------------------------------"     \
      "-----------------------------(%4d/%4d)\n", lineno, Lines[Afile]
    printf "    %s\n", X[Afile, "exact", code]
    for (j = 1; j <= na; j++) {
      split(a[j],b," ")
      printf "%2d: %s\n", j, X[Bfile, "exact", XC[Bfile,"punct", b[2]]]
      code_of_j[j] = b[1]
    }
    # Begin user input
    while(1) {
      r = ""
      printf "  > "
      getline r < "-"
      
      if (r == "q") {
        print "Halting... " lineno -1 " lines of '" Afile "' processed" 
        clean_exit(0)
      }
      else if (r == "e") {
        no_match(code)
        break
      }
      # See the codes being compared
      else if (r == "c") {
        printf "    %20s vs. %-20s\n", code , code_of_j[1]
        for (j = 2; j <= na; j++)
          printf "    %20s vs. %-20s\n", "", code_of_j[j]
      }
      # on getting a number for the correct match
      else if (code_of_j[r]) {
        print code , code_of_j[r], "manual" , Data[ code ], \
          Data[code_of_j[r]]                                \
          >> OUTFILE
        close(OUTFILE)
        break
      }
      else printf "(try again... q = abort, e = no match, c = codes; " \
             "1-9+ = pick)\n"
    }
    delete a ; delete b ; delete code_of_j
  }
  else no_match(code)
}
