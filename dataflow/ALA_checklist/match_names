#!/bin/gawk -f

# Looks for names from list A ("Query set") in list B ("Master set")
# Matching them at different "quality levels", and optionally doing fuzzy
# matching using agrep

# (c) Cam Webb, 2018
# Licence: Public Domain (Via: https://unlicense.org/)

## Dependencies:
# 1. GNU gawk v.4+
# 2. Set $AWKPATH to find function libraries (depunct.awk)
# 3. agrep (https://laurikari.net/tre/)

## Conventions:
# Variables shared among functions and main begin with Capital letters

@include "depunct.awk"

BEGIN{
  config()
  read_args()
  
  ## Read reference names
  read_data(Bfile)

  # make sublists, for agrep
  if (FUZZY) make_agrep_lists(Bfile)

  ## Read query names
  read_data(Afile)

  ## Main loop though the lines of input file A
  for (line = 1; line <= Lines[Afile]; line++) {
    ac = C[Afile, line]
    
    if      (test_eq("exact",   ac)) continue
    else if (test_eq("punct",   ac)) continue
    else if (test_pm("basio",   ac)) continue
    else if (test_pm("exin",    ac)) continue
    else if (test_pm("basexin", ac)) continue

    # # Fuzzy match with user input
    # else if (FUZZY && GL[g[ac]]) {
    #   # send depunct A name to agrep
    #   # Note, a genus spelling mismatch will not be found due to
    #   #   wrong temporary grenus name list
    #   cmd = "agrep -w -k -" FUZZERR " \"" Agsakey[Acode[i]] \
    #     "\" " TEMPDIR "/" Ag[Acode[i]] " | sort -k 2"
    #   agreps = ""
    #   RS = "\x04" 
    #   cmd | getline agreps
    #   close(cmd)
    #   RS = "\n" # needed for interactive input
    #   gsub(/\n$/,"", agreps) # to remove 'default' newline

    #   # If there was an agrep match, list match(s)
    #   if (length(agreps)) {
    #     na = split(agreps, a, "\n")
    #     print "---------------------------------------" \
    #       "-----------------------------------------"
    #     printf "    %s\n", Aname[Acode[i]],    \
    #       Acode[i]
    #     for (j = 1; j <= na; j++) {
    #       split(a[j],b," ")
    #       printf "%2d: %s\n", j, Bname[Bkey0Code[b[2]]], b[1]
    #       code_of_j[j] = b[1]
    #     }
    #     # Begin user input
    #     while(1) {
    #       r = ""
    #       printf "  > "
    #       getline r < "-"
          
    #       if (r == "q") {
    #         print "Halting... " i-1 " lines of " Afile " processed" 
    #         clean_exit(0)
    #       }
    #       else if (r == "n") {
    #         no_match(i)
    #         break
    #       }
    #       # See the codes being compared
    #       else if (r == "c") {
    #         printf "    %20s vs. %-20s\n", Acode[i] , code_of_j[1]
    #         for (j = 2; j <= na; j++)
    #           printf "    %20s vs. %-20s\n", "", code_of_j[j]
    #       }
    #       # on getting a number for the correct match
    #       else if (code_of_j[r]) {
    #         print Acode[i] , code_of_j[r],   \
    #           "manual" , Aname[Acode[i]],                      \
    #           Bname[code_of_j[r]]                                     \
    #           >> OUTFILE
    #         close(OUTFILE)
    #         break
    #       }
    #       else printf "(try again... q = abort, n = no match, 1-9+ = pick)\n"
    #     }
    #     delete a ; delete b ; delete code_of_j
    #   }
    #   else no_match(i)
    # }
    else no_match(ac)
  }

  clean_exit(1)
}

function config() {
  ## Config
  FS = "|"
  OFS= "|"
  PROCINFO["sorted_in"] =  "@ind_str_asc"
  FUZZERR = 5

  # Column order; same in both files
  I_code = 1 ; I_xg = 2  ; I_g = 3  ; I_xs = 4 ; I_s = 5
  I_st = 6   ; I_ssp = 7 ; I_a = 8 
}

function read_args(    arg) {
  ## Read arguments and fail-to usage 
  for (arg = 1; arg < ARGC; arg++) {
    if      (ARGV[arg] == "-a") Afile = ARGV[arg+1]
    else if (ARGV[arg] == "-b") Bfile = ARGV[arg+1]
    else if (ARGV[arg] == "-o") OUTFILE  = ARGV[arg+1]
    else if (ARGV[arg] == "-f") FUZZY    = 1
    else if (ARGV[arg] == "-e") FUZZERR  = ARGV[arg+1]
  }
  if (!Afile || !Bfile || !OUTFILE || ARGC == 1) {
    print "usage:    match_names -a query_names_file -b " \
      "ref_names_file -n outfile [-f [-e fuzz_error]]"
    exit 1
  }

  ## Delete existing OUTFILE
  system("rm -f " OUTFILE)
}


function read_data(filename,     i, nameN, namex) {
  
  while ((getline < filename) > 0) {
    # clean Data of spaces and NULL symbols
    for (i = 1; i <= NF; i++) {
      gsub(/^(NULL|\\N)$/,"",$i)
      $i = cleanspaces($i)
    }

    # lines
    C[filename, ++Lines[filename]] = $I_code
    
    # check for duplicate code
    if (++CodeN[$I_code] > 1) {
      print "Code '" $I_code "' is a duplicate..."
      exit 1
    }

    # For output and loading into DB
    Data[$I_code] = $I_xg OFS $I_g OFS $I_xs OFS $I_s OFS \
      $I_st OFS $I_ssp OFS $I_a
    
    # "exact" string for manual string matching
    X[filename, "exact", $I_code] = cleanspaces($I_xg " " $I_g " " $I_xs " "  \
           $I_s " " $I_st " " $I_ssp " " $I_a)
    XC[filename, "exact", X[filename, "exact", $I_code]] = $I_code
    # Check for duplicate name
    if (++nameN[X[filename, "exact", $I_code]] > 1) {
      print "Error: file " filename ", name '" X[filename, "exact", $I_code] \
        "' is a duplicate..."
      exit 1
    }
    
    ## Keys:
    namex = $I_xg $I_g $I_xs $I_s $I_st $I_ssp

    # NB: using computed regex here, less efficient, but tidier code
    # plain depunct
    apply_regex(filename, $I_code, namex, $I_a, "punct", "") ;
    # depunct, with basionym removed
    apply_regex(filename, $I_code, namex, $I_a, "basio", "^\\([^)]+\\)") ;
    # depunct with 'ex' or 'in' removed
    apply_regex(filename, $I_code, namex, $I_a, "exin", "\\ (ex|in)\\ .*$") ;
    # depunct with basio and 'ex' or 'in' removed
    apply_regex(filename, $I_code, namex, $I_a, "basexin", \
                "(^\\([^)]+\\)|\\ (ex|in)\\ .*$)")
    # genus list
    G[$I_code] = $I_g
  }
}

function make_agrep_lists(filename,    cmd, i) {
  cmd = "mktemp -d"
  cmd | getline TEMPDIR
  # only B names, so far:
  for (i in CodeN) {
    print i " " X[filename, "punct", i]  >> TEMPDIR "/" G[i]
    close(TEMPDIR "/" G[i])
    # variable to track which genera are in the TEMPDIR:
    GL[G[i]]++;
  }
}

function test_eq(method, code,      outmethod) {
  
  outmethod = method == "punct" ? "auto_punct" : method
  # if there is a B code for the A key, using the same method
  if (XC[Bfile, method, X[Afile, method, code]]) {
    print code, XC[Bfile, method, X[Afile, method, code]],    \
      outmethod , Data[code] ,                            \
      Data[XC[Bfile, method, X[Afile, method, code]]] >> OUTFILE
    close(OUTFILE)
    return 1
  }
  else return 0
}

function test_pm(method, code) {

  #^ print X[Afile, "punct", code], XC[Bfile, method, X[Afile, "punct", code]]
  # if there is a B code for the collapsed A key
  if (XC[Bfile, method, X[Afile, "punct", code]]) {
    print code, XC[Bfile, method, X[Afile, "punct", code]],  \
      "auto_" method "-" , Data[code] ,                                 \
      Data[XC[Bfile, method, X[Afile, "punct", code]]] >> OUTFILE
    close(OUTFILE)
    return 1
  }
  
  # if there is a collapse B code for the A key
  else if (XC[Bfile, "punct", X[Afile, method, code]]) {
    print code, XC[Bfile, "punct", X[Afile, method, code]],  \
      "auto_" method "+" , Data[code] ,                            \
      Data[XC[Bfile, "punct", X[Afile, method, code]]] >> OUTFILE
    close(OUTFILE)
    return 1
  }
  else return 0
}

function apply_regex(AB, code, name, auth, method, regex) {

  gsub(regex, "", auth)
  X[AB, method, code] = depunct(name auth)
  XC[AB, method, X[AB, method, code]] = code
  if (++XN[AB, method, X[AB, method, code]] > 1)
    print "Warning: " code  \
        " has duplicate " method " form:\n           "  X[AB, method, code]
}


function cleanspaces(x) {
  # X is an external variable
  gsub(/\ \ */," ", x)
  gsub(/\ *$/, "" , x)
  gsub(/^\ */, "" , x)
  return x
}

function no_match(code) {
  print code "||no_match|" X[Afile, "exact", code] "|||||||||||||" \
        >> OUTFILE
  close(OUTFILE)
}

function clean_exit(status) {
  system("rm -rf "TEMPDIR)
  exit status
}


