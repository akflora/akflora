#!/bin/gawk -f

# Looks for taxonomic names from list A ("Query set") in list B
# ("Reference set") matching them at different "quality levels", and
# optionally doing fuzzy matching using agrep

# (c) Cam Webb, 2018
# Licence: Public Domain (Via: https://unlicense.org/)

## Dependencies:
# 1. GNU gawk v.4+
# 2. agrep (https://laurikari.net/tre/) to use fuzzy matching (-f option)

## Conventions:
# Variables shared among functions and main BEGIN{} start with Capital letters

BEGIN{
  config()
  read_args()
  
  # Read reference names
  read_data(Bfn)

  # make sublists, for agrep
  if (FUZZY) make_agrep_lists(Bfn)

  # Read query names
  read_data(Afn)

  # Main loop though the lines of input file A
  for (line = 1; line <= Lines[Afn]; line++) {
    # ac is the given code associated with a name 
    ac = C[Afn, line]

    # test for exact string match:
    if      (test_eq("exact",   ac)) continue
    # test for exact non-punctuation character match:
    else if (test_eq("punct",   ac)) continue
    # if no author in A and only one author in B, make this default match:
    else if (NA[ac] && NOAUTH && (test_na(ac))) continue
    # start on author variations, first a missing basionym:
    else if (test_pm("basio",   ac)) continue
    # diff basionyms, ok:
    else if (test_eq("basio",   ac)) continue
    # a missing 'ex ...' or 'in ...':
    else if (test_pm("exin",    ac)) continue
    # both missing basionym or ex/in:
    else if (test_pm("basexin", ac)) continue
    # reject a match when A is 'auct.':
    else if (Auct[ac]) no_match(ac)
    # fuzzy matching and manual checking:
    else if (FUZZY && GL[G[ac]]) fuzzy(ac, line)
    else no_match(ac)
  }

  clean_exit(1)
}

function config() {
  FS = "|"
  OFS= "|"
  PROCINFO["sorted_in"] =  "@ind_str_asc"
  FUZZERR = 5

  # Column order; same in both files
  I_code = 1 ; I_xg = 2  ; I_g = 3  ; I_xs = 4 ; I_s = 5
  I_st = 6   ; I_ssp = 7 ; I_a = 8 
}

function read_args(    arg) {
  # Read arguments, check, give usage
  # Note: add -d or -L as first option to do gawk dump or lint
  for (arg = 1; arg < ARGC; arg++) {
    if      (ARGV[arg] == "-a") Afn = ARGV[arg+1]
    else if (ARGV[arg] == "-b") Bfn = ARGV[arg+1]
    else if (ARGV[arg] == "-o") OUTFILE  = ARGV[arg+1]
    else if (ARGV[arg] == "-f") FUZZY    = 1
    else if (ARGV[arg] == "-e") FUZZERR  = ARGV[arg+1]
    else if (ARGV[arg] == "-1") NOAUTH  = 1
  }
  if (!Afn || !Bfn || !OUTFILE || ARGC == 1) {
    print "usage:    match_names -a query_names_file -b " \
      "ref_names_file -n outfile\n            [ -f [ -e fuzz_error ]] [ -1 ]"
    exit 1
  }

  # Delete existing OUTFILE
  system("rm -f " OUTFILE)
}

function read_data(filename,     i, nameN, namex) {
  
  while ((getline < filename) > 0) {
    # clean fields of spaces and NULL symbols
    for (i = 1; i <= NF; i++) {
      gsub(/^(NULL|\\N)$/,"",$i)
      $i = cleanspaces($i)
    }

    # line# to code:
    C[filename, ++Lines[filename]] = $I_code
    
    # check for duplicate code
    if (++CodeN[$I_code] > 1) {
      print "Code '" $I_code "' is a duplicate..."
      exit 1
    }

    # For strucutred output
    Data[$I_code] = $I_xg OFS $I_g OFS $I_xs OFS $I_s OFS \
      $I_st OFS $I_ssp OFS $I_a
    
    # "exact" string for manual string matching
    X[filename, "exact", $I_code] = cleanspaces($I_xg " " $I_g " " $I_xs " "  \
           $I_s " " $I_st " " $I_ssp " " $I_a)
    XC[filename, "exact", X[filename, "exact", $I_code]] = $I_code
    # Check for duplicate name
    if (++nameN[X[filename, "exact", $I_code]] > 1) {
      print "Error: file " filename ", name '" X[filename, "exact", $I_code] \
        "' is a duplicate..."
      exit 1
    }
    
    namex = $I_xg $I_g $I_xs $I_s $I_st $I_ssp

    # NB: using computed regex here, less efficient, but tidier code
    # plain depunct
    apply_regex(filename, $I_code, namex, $I_a, "punct", "")

    # plain depunct no author
    if (!$I_a) NA[$I_code] = 1
    apply_regex(filename, $I_code, namex, "", "noauth", "") 
    XNA[filename, X[filename, "noauth", $I_code]]++

    # depunct, with basionym removed
    apply_regex(filename, $I_code, namex, $I_a, "basio", "^\\([^)]+\\)")
    # depunct with 'ex' or 'in' removed
    apply_regex(filename, $I_code, namex, $I_a, "exin", "\\ (ex|in)\\ .*$")
    # depunct with basio and 'ex' or 'in' removed
    apply_regex(filename, $I_code, namex, $I_a, "basexin", \
                "(^\\([^)]+\\)|\\ (ex|in)\\ .*$)")
    # auct?
    if ($I_a ~ /^auct\.?$/) Auct[$I_code] = 1
    # genus list
    G[$I_code] = $I_g
  }
  close(filename)
}

function make_agrep_lists(filename,    cmd, i) {
  cmd = "mktemp -d"
  cmd | getline TEMPDIR
  # only B names, so far as called, so CodeN only contains B names
  for (i in CodeN) {
    print i " " X[filename, "punct", i]  >> TEMPDIR "/" G[i]
    close(TEMPDIR "/" G[i])
    # variable to track which genera are in the TEMPDIR:
    GL[G[i]]++
  }
}

function test_eq(method, code,      outmethod) {
  
  outmethod = method == "punct" ? "auto_punct" : method
  # if there is a B code for the A key, using the same method
  if (XC[Bfn, method, X[Afn, method, code]]) {
    print code, XC[Bfn, method, X[Afn, method, code]],    \
      outmethod , Data[code] ,                            \
      Data[XC[Bfn, method, X[Afn, method, code]]] >> OUTFILE
    close(OUTFILE)
    return 1
  }
  else return 0
}

function test_na(code) {

  # if there is a single B code for the A key
  if ((XC[Bfn, "noauth", X[Afn, "noauth", code]]) &&        \
      XNA[Bfn, X[Afn, "noauth", code]] == 1) {
    print code, XC[Bfn, "noauth", X[Afn, "noauth", code]],  \
      "noauth" , Data[code] ,                               \
      Data[XC[Bfn, "noauth", X[Afn, "noauth", code]]] >> OUTFILE
    close(OUTFILE)
    return 1
  }
  else return 0
}

function test_pm(method, code) {

  # if there is a B code for the collapsed A key
  if (XC[Bfn, method, X[Afn, "punct", code]]) {
    print code, XC[Bfn, method, X[Afn, "punct", code]],                \
      "auto_" method "-" , Data[code] ,                                \
      Data[XC[Bfn, method, X[Afn, "punct", code]]] >> OUTFILE
    close(OUTFILE)
    return 1
  }
  
  # if there is a collapsed B code for the A key
  else if (XC[Bfn, "punct", X[Afn, method, code]]) {
    print code, XC[Bfn, "punct", X[Afn, method, code]],            \
      "auto_" method "+" , Data[code] ,                            \
      Data[XC[Bfn, "punct", X[Afn, method, code]]] >> OUTFILE
    close(OUTFILE)
    return 1
  }
  else return 0
}

function apply_regex(AB, code, name, auth, method, regex,   i) {

  gsub(regex, "", auth)
  X[AB, method, code] = depunct(name auth)
  XC[AB, method, X[AB, method, code]] = code
  # check for possible duplicate keys. The used match will be the first one
  if ((++XN[AB, method, X[AB, method, code]] > 1) &&
      (method != "noauth")) {
    print "Warning: " code  \
        " has duplicate " method " form:\n           "  X[AB, method, code]
    # inefficient, but seldom called
    for (i in CodeN)
      if ((X[AB, method, i] == X[AB, method, code]) && (i != code))
        print "   with: " i 
  }
}

function cleanspaces(x) {
  # X is an external variable
  gsub(/\ \ */," ", x)
  gsub(/\ *$/, "" , x)
  gsub(/^\ */, "" , x)
  return x
}

function no_match(code) {
  print code "||no_match|" Data[code] "|||||||" \
        >> OUTFILE
  close(OUTFILE)
}

function clean_exit(status) {
  system("rm -rf "TEMPDIR)
  exit status
}

function fuzzy(code, lineno,    cmd, agreps, na, a, b, j, code_of_j, r) {
  
  # send depunct A name to agrep
  # Note, a genus spelling mismatch will not be found due to
  #   wrong temporary genus name list
  cmd = "agrep -w -k -" FUZZERR " \"" X[Afn, "punct", code] "\" " \
    TEMPDIR "/" G[code] " | sort -k 2"
  agreps = ""
  RS = "\x04" 
  cmd | getline agreps
  close(cmd)
  RS = "\n" # needed for interactive input
  gsub(/\n$/,"", agreps) # to remove 'default' newline

  # If there was an agrep match, list match(s)
  if (length(agreps)) {
    na = split(agreps, a, "\n")
    printf "---------------------------------------"     \
      "-----------------------------(%4d/%4d)\n", lineno, Lines[Afn]
    printf "    %s\n", X[Afn, "exact", code]
    for (j = 1; j <= na; j++) {
      split(a[j],b," ")
      printf "%2d: %s\n", j, X[Bfn, "exact", XC[Bfn,"punct", b[2]]]
      code_of_j[j] = b[1]
    }
    # Begin user input
    while(1) {
      r = ""
      printf "  > "
      getline r < "-"
      
      if (r == "q") {
        print "Halting... " lineno - 1 " lines of '" Afn "' processed" 
        clean_exit(0)
      }
      else if (r == "e") {
        no_match(code)
        break
      }
      # See the codes being compared
      else if (r == "c") {
        printf "    %20s vs. %-20s\n", code , code_of_j[1]
        for (j = 2; j <= na; j++)
          printf "    %20s vs. %-20s\n", "", code_of_j[j]
      }
      # on getting a number for the correct match
      else if (code_of_j[r]) {
        print code , code_of_j[r], "manual" , Data[ code ], \
          Data[code_of_j[r]]                                \
          >> OUTFILE
        close(OUTFILE)
        break
      }
      else printf "(try again... q = abort, e = no match, c = codes; " \
             "1-9+ = pick)\n"
    }
    delete a ; delete b ; delete code_of_j
  }
  else no_match(code)
}

function depunct(x) {
  # the master copy of this library is now here in match_names
  
  # See here for data:
  # https://code.activestate.com/recipes/251871-latin1-to-ascii-the-
  #   unicode-hammer/
  # https://stackoverflow.com/questions/1382998/latin-1-to-ascii#1383721
  gsub(/[ùúûü]/,"u", x)
  gsub(/[Ñ]/,"N", x)
  gsub(/[ÀÁÂÃÄÅ]/,"A", x)
  gsub(/[ìíîï]/,"i", x)
  gsub(/[ÒÓÔÕÖØ]/,"O", x)
  gsub(/[Ç]/,"C", x)
  gsub(/[æ]/,"ae", x)
  gsub(/[Ð]/,"D", x)
  gsub(/[ýÿ]/,"y", x)
  gsub(/[ÈÉÊË]/,"E", x)
  gsub(/[ñ]/,"n", x)
  gsub(/[àáâãäå]/,"a", x)
  gsub(/[òóôõöø]/,"o", x)
  gsub(/[ß]/,"b", x)
  gsub(/[ÙÚÛÜ]/,"U", x)
  gsub(/[Þþ]/,"p", x)
  gsub(/[çč]/,"c", x)
  gsub(/[ÌÍÎÏ]/,"I", x)
  gsub(/[ð]/,"d", x)
  gsub(/[èéêë]/,"e", x)
  gsub(/[Æ]/,"Ae", x)
  gsub(/[Ý]/,"Y", x)

  # for using "agrep -w" there can only be alphanumerics and underscore
  # the only key non-punct characters to maintain are "()"
  gsub (/[()]/,"_",x)
  # and "&"
  # [ was: gsub (/\ and\ /," \\& ", x); ]
  gsub (/(\ and\ |&)/,"_",x)
  # Now delete spaces and periods, and all other punctuation:
  gsub(/[^A-Za-z0-9_]/,"", x)
  # [ was gsub(/[ .]/,"", x) ; gsub(/"/,"", x) ]

  # test
  if (x ~ /[^A-Za-z0-9_]/) print "Warning: non al-num in x: " x
  
  return tolower(x)
}
