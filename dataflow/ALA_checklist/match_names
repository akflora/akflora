#!/bin/gawk -f

# Looks for names from list A ("Query set") in list B ("Master set")
# Matching them at different "quality levels", and optionally doing fuzzy
# matching using agrep

# (c) Cam Webb, 2018
# Licence: Public Domain (Via: https://unlicense.org/)

## Dependencies:
# 1. GNU gawk v.4+
# 2. Set $AWKPATH to find function libraries (depunct.awk)
# 3. agrep (https://laurikari.net/tre/)

@include "depunct.awk"

BEGIN{
  ## Config
  FS = "|"
  OFS= "|"
  PROCINFO["sorted_in"] =  "@ind_str_asc"

  # Column order; change if needed
  A_code = 1 ; A_xg = 2  ; A_g = 3  ; A_xs = 4 ; A_s = 5
  A_st = 6   ; A_ssp = 7 ; A_a = 8 
  B_code = 1 ; B_xg = 2  ; B_g = 3  ; B_xs = 4 ; B_s = 5
  B_st = 6   ; B_ssp = 7 ; B_a = 8 

  ## Read arguments and fail-to usage 
  for (arg = 1; arg < ARGC; arg++) {
    if      (ARGV[arg] == "-a") A_infile = ARGV[arg+1]
    else if (ARGV[arg] == "-b") B_infile = ARGV[arg+1]
    else if (ARGV[arg] == "-n") BASENAME = ARGV[arg+1]
    else if (ARGV[arg] == "--fuzzy") FUZZY = 1
  }
  if (!A_infile || !B_infile || !BASENAME || ARGC == 1) {
    print "usage:    match_names -a names_query_file -b " \
      "match_in_file -n outfile_basename"
    exit 1
  }

  ## Delete existing files
  system("rm -f " BASENAME "_match")
  
  ## Read data and basic checking for uniqueness
  read_data()

  ## Main loop though the lines of input file A
  for (i = 1; i <= Alines ; i++) {
    # 1. Exact match
    if (BgsaStrCode[AgsaStr[AorderedCode[i]]]) {
      print AorderedCode[i] , BgsaStrCode[AgsaStr[AorderedCode[i]]],    \
        "gsa_exact" , Adata[AorderedCode[i]],                         \
        Bdata[BgsaStrCode[AgsaStr[AorderedCode[i]]]]                  \
        >> BASENAME "_match"
      close(BASENAME "_match")
    }
    
    # 2. Variant punctuation match (case, ascii, space, period... depunct())
    #    ... may not be unique in B; warning given when reading data
    else if (BgsakeyCode[Agsakey[AorderedCode[i]]]) {
      print AorderedCode[i] , BgsakeyCode[Agsakey[AorderedCode[i]]],    \
        "gsa_depunct" , Adata[AorderedCode[i]],                       \
        Bdata[BgsakeyCode[Agsakey[AorderedCode[i]]]]                  \
        >> BASENAME "_match"
      close(BASENAME "_match")
    }
    
    # 3. Variant punctuation match and missing basionym
    else if (BgsaBkeyCode[Agsakey[AorderedCode[i]]]) {
      print AorderedCode[i] , BgsaBkeyCode[Agsakey[AorderedCode[i]]],   \
        "gsa_basio" , Adata[AorderedCode[i]],                         \
        Bdata[BgsaBkeyCode[Agsakey[AorderedCode[i]]]]                 \
        >> BASENAME "_match"
      close(BASENAME "_match")
    }

    # 4. Variant punctuation match and missing 'ex'
    else if (BgsaEkeyCode[Agsakey[AorderedCode[i]]]) {
      print AorderedCode[i] , BgsaEkeyCode[Agsakey[AorderedCode[i]]],   \
        "gsa_ex" , Adata[AorderedCode[i]],                            \
        Bdata[BgsaEkeyCode[Agsakey[AorderedCode[i]]]]                 \
        >> BASENAME "_match"
      close(BASENAME "_match")
    }
    # 5. Variant punctuation match and missing basionym and missing 'ex'
    else if (BgsaBEkeyCode[Agsakey[AorderedCode[i]]]) {
      print AorderedCode[i] , BgsaBEkeyCode[Agsakey[AorderedCode[i]]],   \
        "gsa_bas_ex" , Adata[AorderedCode[i]],                         \
        Bdata[BgsaBEkeyCode[Agsakey[AorderedCode[i]]]]                 \
        >> BASENAME "_match"
      close(BASENAME "_match")
    }

    # 6. Fuzzy match with user input
    else if (FUZZY && BgN[Ag[AorderedCode[i]]]) {
      # send depunct A name to agrep
      # Note, a genus spelling mismatch will not be found due to
      #   wrong temporary grenus name list
      cmd = "agrep -k -2 \"" Agsakey[AorderedCode[i]] \
        "\" " TEMPDIR "/" Ag[AorderedCode[i]]
      agreps = ""
      RS = "\x04" 
      cmd | getline agreps
      close(cmd)
      RS = "\n" # needed for interactive input
      gsub(/\n$/,"", agreps) # to remove 'default' newline

      # If there was an agrep match, list match(s)
      if (length(agreps)) {
        na = split(agreps, a, "\n")
        print "---------------------------------------" \
          "-----------------------------------------"
        printf "    %s\n", AgsaStr[AorderedCode[i]],    \
          AorderedCode[i]
        for (j = 1; j <= na; j++) {
          split(a[j],b," ")
          printf "%2d: %s\n", j, BgsaStr[BgsakeyCode[b[2]]], b[1]
          code_of_j[j] = b[1]
        }
        # Begin user input
        while(1) {
          r = ""
          printf "  > "
          getline r < "-"
          
          if (r == "q") {
            print "Halting... " i-1 " lines of " A_infile " processed" 
            clean_exit(0)
          }
          else if (r == "n") {
            no_match(i)
            break
          }
          # See the codes being compared
          else if (r == "c") {
            printf "    %20s vs. %-20s\n", AorderedCode[i] , code_of_j[1]
            for (j = 2; j <= na; j++)
              printf "    %20s vs. %-20s\n", "", code_of_j[j]
          }
          # on getting a number for the correct match
          else if (code_of_j[r]) {
            print AorderedCode[i] , code_of_j[r],   \
              "manual" , AgsaStr[AorderedCode[i]],                      \
              BgsaStr[code_of_j[r]]                                     \
              >> BASENAME "_match"
            close(BASENAME "_match")
            break
          }
          else printf "(try again... q = abort, n = no match, 1-9+ = pick)\n"
        }
        delete a ; delete b ; delete code_of_j
      }
      else no_match(i)
    }
    else no_match(i)
  }
  
  clean_exit(1)
}

function read_data(    i, BcodeN, BgsaStrN, BgsakeyN, AcodeN, AgsaStrN, \
                       AgsakeyN, cmd) {
  # I played with collapsing 'Aabc[' to 'abc[1][' but while it would
  # have allowed some saving of code (e.g., in this reading in phase)
  # it was much harder to work with

  RS = "\n"
  ## B list first
  
  while ((getline < B_infile) > 0) {
    # clean data of spaces and NULL symbols
    for (i = 1; i <= NF; i++) {
      gsub(/^(NULL|\\N)$/,"",$i)
      $i = cleanspaces($i)
    }
    # check for duplicate code
    if (++BcodeN[$B_code] > 1) {
      print "B code '" $B_code "' is a duplicate..."
      exit 1
    }

    # For output and loading into DB
    Bdata[$B_code] = $B_xg OFS $B_g   OFS $B_xs OFS $B_s OFS    \
                       $B_st OFS $B_ssp OFS $B_a # var needed?

    # string for manual string matching
    BgsaStr[$B_code] = cleanspaces($B_xg " " $B_g " " $B_xs " "     \
                           $B_s " " $B_st " " $B_ssp " " $B_a)
    # Reverse: name -> code
    BgsaStrCode[BgsaStr[$B_code]] = $B_code
    # Check for duplicate name
    if (++BgsaStrN[BgsaStr[$B_code]] > 1) {
      print "B name '" BgsaStr[$B_code] "' is a duplicate..."
      exit 1
    }
    # de_punct keys:
    Bgsakey[$B_code] = depunct($B_xg $B_g $B_xs $B_s    \
                      $B_st $B_ssp $B_a)
    if (++BgsakeyN[Bgsakey[$B_code]] > 1)
      print "Warning: " $B_code " has duplicate depunct form: \n           " \
        Bgsakey[$B_code]
    BgsakeyCode[Bgsakey[$B_code]] = $B_code;  # may not be not unique, care!
    # same again, with Basionym removed
    BgsaBkey[$B_code] = depunct($B_xg $B_g $B_xs $B_s                   \
                                $B_st $B_ssp gensub(/\([^)]+\)/,"","G",$B_a))
    BgsaBkeyCode[BgsaBkey[$B_code]] = $B_code;  # may not be not unique, care
    # same again, with 'ex' removed
    BgsaEkey[$B_code] = depunct($B_xg $B_g $B_xs $B_s                   \
                                $B_st $B_ssp gensub(/\ ex\ .*$/,"","G",$B_a))
    BgsaEkeyCode[BgsaEkey[$B_code]] = $B_code;  # may not be not unique, care
    # same again, with basionym and 'ex' removed
    BgsaBEkey[$B_code] = \
      depunct($B_xg $B_g $B_xs $B_s $B_st $B_ssp \
              gensub(/\ ex\ .*$/,"","G", gensub(/\([^)]+\)/,"","G",$B_a)))
    BgsaBEkeyCode[BgsaBEkey[$B_code]] = $B_code;  # may not be not unique, care
    # genus list
    Bg[$B_code] = $B_g
  }

  ## A list
  while ((getline < A_infile) > 0) {
    # clean data
    for (i = 1; i <= NF; i++) {
      gsub(/^(NULL|\\N)$/,"",$i)
      $i = cleanspaces($i)
    }
    if (++AcodeN[$A_code] > 1) {
      print "A code '" $A_code "' is a duplicate..."
      exit 1
    }
    # main linenumber -> code array
    AorderedCode[++Alines] = $A_code
    # data for output
    Adata[$A_code]   = $A_xg OFS $A_g OFS $A_xs OFS $A_s OFS    \
                           $A_st OFS $A_ssp OFS $A_a
    # string for manual string matching
    AgsaStr[$A_code] = cleanspaces($A_xg " " $A_g " " $A_xs " " $A_s " " \
                                   $A_st " " $A_ssp " " $A_a)
    # test for duplicate code
    if (++AgsaStrN[AgsaStr[$A_code]] > 1) {
      print "A code '" $A_code "' name '" AgsaStr[$A_code] \
        "' is a duplicate..."
      exit 1
    }
    # Depuncted key
    Agsakey[$A_code] = depunct($A_xg $A_g $A_xs $A_s    \
                                  $A_st $A_ssp $A_a)
    if (++AgsakeyN[Agsakey[$A_code]] > 1)
      print "Warning: " $A_code " has duplicate depunct form:\n           "\
        Agsakey[$A_code]
    # genus list
    Ag[$A_code] = $A_g
  }

  # make sublists, for agrep
  if (FUZZY) {
    cmd = "mktemp -d"
    cmd | getline TEMPDIR
    for (i in Bdata) {
      print i " " Bgsakey[i]  >> TEMPDIR "/" Bg[i]
      close(TEMPDIR "/" Bg[i])
      BgN[Bg[i]]++;
    }
  }
}

function cleanspaces(x) {
  # x is an external variable
  gsub(/\ \ */," ", x)
  gsub(/\ *$/, "" , x)
  gsub(/^\ */, "" , x)
  return x
}

function no_match(x) {
  print AorderedCode[x] "||no_match|" AgsaStr[AorderedCode[x]] "|||||||||||||" \
        >> BASENAME "_match"
  close(BASENAME "_match")
}

function clean_exit(status) {
  system("rm -rf TEMPDIR")
  exit status
}


