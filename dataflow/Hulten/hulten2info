#!/usr/bin/gawk -f


# Images in hulten are 4510 wide x 6590 high

BEGIN{

  # "mktemp -d" | getline TMPDIR;

  Page    = ARGV[2]
  Imgfile = "p" ARGV[2] ".tiff"
  SubimgN = 0
  
  # Check arguments
  if (ARGC == 0) exit
  else if (ARGV[1] == "split") {
    if (ARGC != 3) exit

    # extract the image from the PDF
    export(Page, Imgfile)

    # TMP v-----------------------------

    # Imgfile = "maps.tiff"
    # chunkup(3020, 1145, 0, 0, Imgfile, 1, 300)
    # for (i in Chunk["len"]) 
    #   print "band " i ", top " Chunk["vec"][i] ", hgt " Chunk["len"][i]

    # # for (j in Chunk["len"]) {
    # # assume 2: map 1
    # W[++SubimgN] = Chunk["len"][1]
    # H[SubimgN]   = 1145
    # X[SubimgN]   = Chunk["vec"][1]
    # Y[SubimgN]   = 0
    # N[SubimgN]   = Page "-" SubimgN "-m1.tiff"
    # # map 2
    # W[++SubimgN] = Chunk["len"][2]
    # H[SubimgN]   = 1145
    # X[SubimgN]   = Chunk["vec"][2]
    # Y[SubimgN]   = 0
    # N[SubimgN]   = Page "-" SubimgN "-m2.tiff"
    # delete(Chunk)  # Clear this, to use for second pass
    
    # for (i in W)
    #    #   printf "%4d  %4d  %4d  %4d  %s\n", W[i], H[i], X[i], Y[i], N[i]
    #   system("display -crop " W[i] "x" H[i] "+" X[i] "+" Y[i] " -resize 500x500 -title " N[i] " tiff/maps.tiff &")

    # exit

    # TMP ^-----------------------------

    
    # first pass, slicing off the stop 450 page header,
    #   and a bit of the bottom, scanning horizontally
    chunkup(4510, 6000, 0, 450, Imgfile, 2, 100)

    # for (i in Chunk["len"]) 
    #  print "band " i ", top " Chunk["vec"][i] ", hgt " Chunk["len"][i]

    # make subimages
    for (i in Chunk["len"]) { 
      # odd page
      if ((Page/2) != int(Page/2)) {
        # text
        W[++SubimgN] = 3050            ;  H[SubimgN]   = Chunk["len"][i]
        X[SubimgN]   = 0               ;  Y[SubimgN]   = Chunk["vec"][i]
        N[SubimgN]   = Page "-" SubimgN "-t.tiff"
        # illustration
        W[++SubimgN] = 1460            ;  H[SubimgN]   = Chunk["len"][i]
        X[SubimgN]   = 3050            ;  Y[SubimgN]   = Chunk["vec"][i]
        N[SubimgN]   = Page "-" SubimgN "-i.tiff"
      }
      else {
        # even page
        W[++SubimgN] = 3020            ;  H[SubimgN]   = Chunk["len"][i]
        X[SubimgN]   = 1490            ;  Y[SubimgN]   = Chunk["vec"][i]
        N[SubimgN]   = Page "-" SubimgN "-t.tiff"
        # illustration
        W[++SubimgN] = 1490            ;  H[SubimgN]   = Chunk["len"][i]
        X[SubimgN]   = 0               ;  Y[SubimgN]   = Chunk["vec"][i]
        N[SubimgN]   = Page "-" SubimgN "-i.tiff"
      }
    }
  }
  delete(Chunk) 

  # View the main image
  system("display -resize x1000 tiff/p" Page ".tiff &")

  # second pass, slicing off the maps
  for (i in W) {
    if (N[i] ~ /-t\./) {
      print N[i] > "/dev/stderr"
      chunkup(W[i], H[i], X[i], Y[i], Imgfile, 2, 200)
      # assume 2 parts: maps
      W[++SubimgN] = W[i]
      H[SubimgN]   = Chunk["len"][1]
      X[SubimgN]   = X[i]
      Y[SubimgN]   = Chunk["vec"][1]
      N[SubimgN]   = Page "-" SubimgN "-m.tiff"
      # just text
      W[++SubimgN] = W[i]
      H[SubimgN]   = Chunk["len"][2]
      X[SubimgN]   = X[i]
      Y[SubimgN]   = Chunk["vec"][2]
      N[SubimgN]   = Page "-" SubimgN "-tt.tiff"
      delete(Chunk) 
    }
  }

  # exit
  # for (i in W)
  #   system("display -crop " W[i] "x" H[i] "+" X[i] "+" Y[i] " -resize 500x500 -title " N[i] " tiff/p" Page ".tiff &")

  
  # exit
  
  # third pass, slicing up the maps
  for (i in W) {
    if (N[i] ~ /-m\./) {
      print N[i] > "/dev/stderr"
      chunkup(W[i], H[i], X[i], Y[i], Imgfile, 1, 300)
      # assume 2: map 1
      W[++SubimgN] = Chunk["len"][1]
      H[SubimgN]   = H[i]
      X[SubimgN]   = Chunk["vec"][1]
      Y[SubimgN]   = Y[i]
      N[SubimgN]   = Page "-" SubimgN "-m1.tiff"
      # map 2
      W[++SubimgN] = Chunk["len"][2]
      H[SubimgN]   = H[i]
      X[SubimgN]   = Chunk["vec"][2]
      Y[SubimgN]   = Y[i]
      N[SubimgN]   = Page "-" SubimgN "-m2.tiff"
      delete(Chunk)  # Clear this, to use for second pass
    }
  }
  
  for (i in W)
  #   printf "%4d  %4d  %4d  %4d  %s\n", W[i], H[i], X[i], Y[i], N[i]
    system("display -crop " W[i] "x" H[i] "+" X[i] "+" Y[i] " -resize 500x500 -title " N[i] " tiff/p" Page ".tiff &")
  
  # system("rm -rf " TMPDIR)
  exit 1
  
}

function export(page, imgfile,     paper){
  paper = paperpage(page)
  print "Extracting book page " page " (pdf page " paper ")" > "/dev/stderr"
  system("cd tiff; pdfimages -tiff -f " paper " -l " paper \
         " ../hulten.pdf tmp ; mv tmp-000.tif " imgfile " ; rm -f tmp*")
}

function chunkup(w, h, x, y, infile, orient, dim                     \
                 , cmd, c, bn, thres, j, i, bot, pad, top, hgt) {
  
  # orient=2: scan for horiz gaps; orient=1: scan for vert gaps
  
  # resize to ~1/60 size, this blurs the content, but maintains the major
  # (but not inter-line) spaces.
  cmd = "convert tiff/" infile " -crop " w "x" h "+" x "+" y \
    " -resize " dim "x" dim " -threshold 97% -depth 1 txt:-"
  # print cmd
  system("display -crop " w "x" h "+" x "+" y    \
         " -resize " dim "x" dim " -threshold 97% -depth 1 tiff/" infile " & ") 
  while ((cmd | getline) > 0 ) {
    gsub(/:/,"",$1)
    # only lines that have coordinates
    if ($1 ~ ",") {
      split($1,c,",")  # coordinates are xpix, ypix
      if ($3 == "#000000") bn[c[orient]]++
    }
  }

  thres = 1  # 3 black out of 75 -> row is black ; test on p112
  bn[-1] = 0 # coordinates numbered from 0, line beyond top is white
  j = 0
  for (i = 0; i < dim; i++) {
    # black
    if (bn[i] > thres) {
      # change to black
      if (bn[i-1] <= thres) {
        # new band
        j++
        top[j] = i
      }
    }
    else {
      # change to white
      if (bn[i-1] > thres) {
        # new band
        bot[j] = i
      }
    }
  }  

  # end black band if last line was black 
  if (!bot[j]) bot[j] = dim

  # pixel padding
  pad = 10
  if (orient == 1) {
    h = w # if scanning vertically, the longest dim is width
    y = x #                         and we add the x, not y
  }
  # for each band
  for (i in top) {
    Chunk["len"][i] =     (bot[i]- top[i]) * int(h / dim)  + pad + pad
    Chunk["vec"][i] =  y + top[i]          * int(h / dim)  - pad
  }
}

function paperpage(page    , p1, p2, i) {

  # page structure of scan
  p1[1]  = 23;
  p1[8]  ="M"; p1[9]  ="M"; p1[10]  =30
  p1[40] ="M"; p1[41] ="M"; p1[42]  =60
  p1[104]="M"; p1[105]="M"; p1[106]=122
  p1[456]=480
  for (i = 1; i <= 960 ; i++) {
    if (p1[i]) 
      p2[i] = p1[i]
    else
      p2[i] = p2[i-1] + 1
  }

  if ((page < 1) || (page > 960)) {
    print "page out of range" > "/dev/stderr"
    exit 0
  }
  else if (p2[page] == "M") {
    print "page " page " missing" > "/dev/stderr"
    exit 0
  }
  else
    return p2[page]
}

# ImageMagick tricks

# magick display -crop 4510x6000+0+450 -resize x1080 p26.tif

# Old method for finding whitespace, use slim bands
# for h in `seq 1000 200 5000`
# do
#   BLACK=`convert out.tif -crop 4510x10+0+$h -threshold 80%             \
#     -format %c -define histogram:unique-colors=true histogram:info:-    \
#     | gawk 'BEGIN{z=0} /#000000/ {gsub(/:/,"",$1); if ($1+0 > 100) z=1}   \
#            END{print z}'`
#     # record the first
#     if [ $BLACK -eq 0 -a $INWHITE -eq 0 ]
#     then
#         let WSTART=h
#         let INWHITE=1
#     elif [ $BLACK -eq 1 -a $INWHITE -eq 1 ]
#     then
#         let WEND=h-190
#         let INWHITE=0
#         # assume that the main break has been found and bail
#         break
#     fi
#     # echo $h $BLACK $INWHITE $WSTART $WEND 
# done
# let SPLIT=`gawk "BEGIN{print int($WSTART+(($WEND-$WSTART)/2))}"`
# echo $WSTART $WEND $SPLIT
# # now crop:
# let H2=6000-$SPLIT
# convert out.tif -crop 4510x$SPLIT+0+0 top.tif
# convert out.tif -crop 4510x$H2+0+$SPLIT bot.tif

