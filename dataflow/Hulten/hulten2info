#!/usr/bin/gawk -f


# Images in hulten are 4510 wide x 6590 high

BEGIN{

  Page    =     ARGV[2]
  Imgfile = "p" ARGV[2] ".tiff"
  Img     = 0    # image number
  pad     = 10
  
  # Check arguments
  if (ARGC == 0) exit
  else if (ARGV[1] == "split") {
    if (ARGC != 3) exit

    # extract the image from the PDF
    export(Page, Imgfile)
    # View the main image
    system("display -resize x1000 tiff/" Imgfile " &")

    # first pass, slicing off the top 450 page header,
    #   and a bit of the bottom, scanning by rows
    chunkup(4510, 6000, 0, 450, Imgfile, 2, 100)
    # returns an array Chunk with n chunks: starting row and length of rows

    # for (i in Chunk["len"]) 
    #  print "band " i ", top " Chunk["vec"][i] ", hgt " Chunk["len"][i]

    # for each horizontal chunk, divide text from illustrations
    for (i in Chunk["len"]) { 
      # odd page
      # <--- 3050 text ---><--- 1460 ill --->    sum=4510 
      if ((Page/2) != int(Page/2)) {
        # text
        W[++Img] = 3050    ;  H[Img] = Chunk["len"][i] + 2*pad
        X[Img]   = 0       ;  Y[Img] = Chunk["vec"][i] +   pad
        N[Img]   =            Page "-" Img "-t.tiff"
        # illustration
        W[++Img] = 1460    ;  H[Img] = Chunk["len"][i] + 2*pad
        X[Img]   = 3050    ;  Y[Img] = Chunk["vec"][i] +   pad
        N[Img]   =            Page "-" Img "-i.tiff"
      }
      else {
        # even page
        W[++Img] = 3020    ;  H[Img] = Chunk["len"][i] + 2*pad
        X[Img]   = 1490    ;  Y[Img] = Chunk["vec"][i] +   pad
        N[Img]   =            Page "-" Img "-t.tiff"
        # illustration
        W[++Img] = 1490    ;  H[Img] = Chunk["len"][i] + 2*pad
        X[Img]   = 0       ;  Y[Img] = Chunk["vec"][i] +   pad
        N[Img]   =            Page "-" Img "-i.tiff"
      }
    }
  }

  #for (i in W)
  #   system("display -crop " W[i] "x" H[i] "+" X[i] "+" Y[i] " -resize 500x500 -title " N[i] " tiff/p" Page ".tiff &")
  
  # second pass, slicing off the maps
  for (i in W) {
    if (N[i] ~ /-t\./) {
      # print N[i] > "/dev/stderr"
      chunkup(W[i], H[i], X[i], Y[i], Imgfile, 2, 200)
      # assume 2 parts: maps
      W[++Img] = W[i]      ;  H[Img] = Chunk["len"][1] + 2*pad
      X[Img]   = X[i]      ;  Y[Img] = Chunk["vec"][1] +   pad
      N[Img]   =              Page "-" Img "-m.tiff"
      # the text
      W[++Img] = W[i]      ;  H[Img] = Chunk["len"][2] + 2*pad
      X[Img]   = X[i]      ;  Y[Img] = Chunk["vec"][2] +   pad
      N[Img]   =              Page "-" Img "-tt.tiff"
    }
  }

  # exit
  # for (i in W)
  #   system("display -crop " W[i] "x" H[i] "+" X[i] "+" Y[i] " -resize 500x500 -title " N[i] " tiff/p" Page ".tiff &")

  # exit
  
  # third pass, slicing up the maps
  for (i in W) {
    if (N[i] ~ /-m\./) {
      print N[i] > "/dev/stderr"
      chunkup(W[i], H[i], X[i], Y[i], Imgfile, 1, 300)
      # assume 2: map 1
      W[++Img] = Chunk["len"][1]
      H[Img]   = H[i]
      X[Img]   = Chunk["vec"][1]
      Y[Img]   = Y[i]
      N[Img]   = Page "-" Img "-m1.tiff"
      # map 2
      W[++Img] = Chunk["len"][2]
      H[Img]   = H[i]
      X[Img]   = Chunk["vec"][2]
      Y[Img]   = Y[i]
      N[Img]   = Page "-" Img "-m2.tiff"
    }
  }

  printf "%4s  %4s  %4s  %4s  %s\n", "W", "H", "X", "Y", "name"
  for (i in W)
    printf "%4d  %4d  %4d  %4d  %s\n", W[i], H[i], X[i], Y[i], N[i]
    # system("display -crop " W[i] "x" H[i] "+" X[i] "+" Y[i] " -resize 500x500 -title " N[i] " tiff/p" Page ".tiff &")
  
  exit 1
  
}

function export(page, imgfile,     paper){
  paper = paperpage(page)
  print "Extracting book page " page " (pdf page " paper ")" > "/dev/stderr"
  system("cd tiff; pdfimages -tiff -f " paper " -l " paper \
         " ../hulten.pdf tmp ; mv tmp-000.tif " imgfile " ; rm -f tmp*")
}


function chunkup(w, h, x, y, infile, orient, dim                     \
                 , cmd, c, bn, thres, j, i, bot, pad, top, hgt) {
  
  # orient=2: scan for horiz gaps; orient=1: scan for vert gaps
  
  # resize to ~1/60 size, this blurs the content, but maintains the major
  # (but not inter-line) spaces.
  cmd = "convert tiff/" infile " -crop " w "x" h "+" x "+" y \
    " -resize " dim "x" dim " -threshold 97% -depth 1 txt:-"
  # print cmd
  system("display -crop " w "x" h "+" x "+" y    \
         " -resize " dim "x" dim " -threshold 97% -depth 1 tiff/" infile " & ") 
  while ((cmd | getline) > 0 ) {
    gsub(/:/,"",$1)
    # only lines that have coordinates
    if ($1 ~ ",") {
      split($1,c,",")  # coordinates are xpix, ypix
      if ($3 == "#000000") bn[c[orient]]++
    }
  }

  thres = 1  # 3 black out of 75 -> row is black ; test on p112
  bn[-1] = 0 # coordinates numbered from 0, line beyond top is white
  j = 0
  for (i = 0; i < dim; i++) {
    # black
    if (bn[i] > thres) {
      # change to black
      if (bn[i-1] <= thres) {
        # new band
        j++
        top[j] = i
      }
    }
    else {
      # change to white
      if (bn[i-1] > thres) {
        # new band
        bot[j] = i
      }
    }
  }  

  # end black band if last line was black 
  if (!bot[j]) bot[j] = dim

  # pixel padding
  pad = 10
  if (orient == 1) {
    h = w # if scanning vertically, the longest dim is width
    y = x #                         and we add the x, not y
  }

  if (isarray(Chunk)) delete Chunk  # clear array if exists
  # for each band
  for (i in top) {
    Chunk["len"][i] =      (bot[i]- top[i]) * int(h / dim)   # + pad + pad
    Chunk["vec"][i] =  y + (top[i]          * int(h / dim))  # - pad
  }
}

function paperpage(page    , p1, p2, i) {

  # page structure of scan
  p1[1]  = 23;
  p1[8]  ="M"; p1[9]  ="M"; p1[10]  =30
  p1[40] ="M"; p1[41] ="M"; p1[42]  =60
  p1[104]="M"; p1[105]="M"; p1[106]=122
  p1[456]=480
  for (i = 1; i <= 960 ; i++) {
    if (p1[i]) 
      p2[i] = p1[i]
    else
      p2[i] = p2[i-1] + 1
  }

  if ((page < 1) || (page > 960)) {
    print "page out of range" > "/dev/stderr"
    exit 0
  }
  else if (p2[page] == "M") {
    print "page " page " missing" > "/dev/stderr"
    exit 0
  }
  else
    return p2[page]
}

# ImageMagick tricks

# magick display -crop 4510x6000+0+450 -resize x1080 p26.tif

# Old method for finding whitespace, use slim bands
# for h in `seq 1000 200 5000`
# do
#   BLACK=`convert out.tif -crop 4510x10+0+$h -threshold 80%             \
#     -format %c -define histogram:unique-colors=true histogram:info:-    \
#     | gawk 'BEGIN{z=0} /#000000/ {gsub(/:/,"",$1); if ($1+0 > 100) z=1}   \
#            END{print z}'`
#     # record the first
#     if [ $BLACK -eq 0 -a $INWHITE -eq 0 ]
#     then
#         let WSTART=h
#         let INWHITE=1
#     elif [ $BLACK -eq 1 -a $INWHITE -eq 1 ]
#     then
#         let WEND=h-190
#         let INWHITE=0
#         # assume that the main break has been found and bail
#         break
#     fi
#     # echo $h $BLACK $INWHITE $WSTART $WEND 
# done
# let SPLIT=`gawk "BEGIN{print int($WSTART+(($WEND-$WSTART)/2))}"`
# echo $WSTART $WEND $SPLIT
# # now crop:
# let H2=6000-$SPLIT
# convert out.tif -crop 4510x$SPLIT+0+0 top.tif
# convert out.tif -crop 4510x$H2+0+$SPLIT bot.tif

