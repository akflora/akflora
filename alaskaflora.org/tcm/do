#!/bin/gawk -f

# A webapp for managing Taxon Concept Mapping data with a MySQL DB
# (c) Cam Webb <cw@camwebb.info>, 2020; License: GPL v3

# @include "/usr/local/share/awk/util_http.awk"
@include "../../lib/db_secrets.awk"

# TODO - create e.g., 'linked names' link in show pubs leading to a WHERE
# DEV - use -L to lint on regular basis

BEGIN{
  PROCINFO["sorted_in"] = "@ind_str_asc"

  # Init
  DATABASE = "tcm"
  # Config:
  #   table1 { table_atts { table, full_name, sort_field, foreign_show } /
  #   fields { field1 { fieldname, full_name, ci, sort_order , foreign_id? } ;
  #           field2 ; ... | table2 | ...
  Config = \
    "pub , Publication , auth , CONCAT%5FWS('_'%2C_`code`%2C_`auth`)   /" \
    "  id   , ID     , i , 0 ,          ;" \
    "  code , Code   , c , 1  ,         ;" \
    "  auth , Author , c , 2   ,        |" \
    "name ,Taxon_Name , code , code    /" \
    "  id    , ID    , i , 0    ,       ;" \
    "  code  , Code  , c , 1    ,       ;" \
    "  genus, Genus , c,   2    ,       ;" \
    "  species, Species, c, 3   ,       ;" \
    "  author, Author, c , 4     ,      ;" \
    "  pubID , Publication ,i , 5 , pub      "
  config()
  db_secrets()

  # READ QUERY STRING
  split(ENVIRON["QUERY_STRING"], qs, "&")
  for (q in qs) {
    split(qs[q], qp, "=")
    f[qp[1]] = substr(urldecode(qp[2]),1,2000)
  }
  clean_quotes();
  
  # DETERMINE AND EXECUTE METHOD
  if (f["table"]) {
    if (f["action"] == "show") 
      show()
    else if ((f["action"] == "add") || (f["action"] == "edit")) 
      addedit()
  }
  else defaultpage()
  
}

# ========================= Pages =========================================

function header(title) {
  # version history: [chars app] -> here
  
  # Use html5
  print "Content-type: text/html\n"
  print "<!DOCTYPE html>"
  print "<html xmlns=\"http://www.w3.org/1999/xhtml\">"
  print "<head><title>" title "</title>"
  print "<meta http-equiv=\"Content-Type\" content=\"text/html; \
           charset=utf-8\" />"
  print "<link href=\"https://fonts.googleapis.com/css?family=Montserrat\" \
           rel=\"stylesheet\"/>"
  print "<link href=\"../img/akflora.ico\" rel=\"shortcut icon\" \
           type=\"image/x-icon\"/>"
  print "<style>"
  print "body { font-size: 14px; font-family: 'Montserrat', " \
    "Verdana, Arial, Helvetica, sans-serif; }"
  print ".main {width: 500px; padding-top: 30px; margin-left: auto;"\
    "  margin-right: auto; }"
  print ".navbar { float: right; margin-bottom: 10px;}"
  print "select , option { font-size: 14px }"
  print "table { border-collapse: collapse }"
  print "td, th { border: 1px solid black; padding: 5px }"
  print "a { color:#15358d; text-decoration:none; border-bottom-style:none }"
  print "a:visited { color:#9f1dbc }"
  print "a:hover {color:#15358d; border-bottom-style:solid; \
	     border-bottom-width:thin }"
  print "</style>"
  print "</head>\n<body>"
  print "<div class=\"main\">"
}


function footer() {
  print "</div>"
  print "</body>\n</html>";
}


function defaultpage(   i)
{
  header("TCM");
  navbar()
  
  print "<h1>TCM</h1>"
  print "<p>Go to table:</p>" 
  print "<ul>"
  for (i in Tlabel)
    print "<li><a href=\"do?table=" i "&amp;action=show\">" Tlabel[i]   \
      "</a></p>"
  print "</ul>"
  
  footer()
}


function show(      x, n, i, j, sql) {
  # version history: this is original version
  
  header(Tlabel[f["table"]])

  navbar()
  
  print "<h1>" Tlabel[f["table"]] "</h1>"
  
  if (f["preaction"])
    preaction()
  
  print "<table>"

  # Table header
  print "<tr>"
  for (i = 1; i <= length(Forder[f["table"]]); i++)
    print "<th>" Flabel[f["table"]][Forder[f["table"]][i]] "</th>"
  print "<th style=\"border:none;\"></th><th style=\"border:none;\"></th>"
  print "</tr>"

  make_lookup()
  
  # Table rows
  if (f["where"])
    where = "WHERE " gensub(/\\'/,"'","G",f["where"]) 
  db_query(DATABASE, "SELECT * FROM `" f["table"] "` " where \
           " ORDER BY `" Tsort[f["table"]] ";" )
  for (i = 1; i <= DBQr; i++) {
    print "<tr name=\"id" DBQ[i,"id"] "\">"
    for (j = 1; j <= length(Forder[f["table"]]); j++) {
      # show lookup value if the field is a foreign key
      if (Fforid[f["table"]][Forder[f["table"]][j]]) {
        print "<td><a href=\"do?table=" \
          Fforid[f["table"]][Forder[f["table"]][j]]                     \
          "&amp;action=show#id" DBQ[i , Forder[f["table"]][j]] "\">"    \
          Lookup[ Fforid[f["table"]][Forder[f["table"]][j]] ][          \
            DBQ[i , Forder[f["table"]][j]]] "</a></td>"
      }
      else
        print "<td>" DBQ[i,Forder[f["table"]][j]] "</td>"
    }
    # Edit
    print "<td style=\"border:none;\"><a href=\"do?table=" f["table"] \
      "&amp;action=edit&amp;id=" DBQ[i,"id"] "\">E</a></td>"
    # Delete
    print "<td style=\"border:none;\"><a href=\"do?table=" f["table"] \
      "&amp;action=show&amp;preaction=delete&amp;id="                   \
      DBQ[i,"id"] "\" onclick=\"return"                                 \
      " confirm('Confirm deletion')\">D</a></td>"
    print "</tr>"
  }
  db_clear()

  print "</table>"
  print "<p><a href=\"do?table=" f["table"] "&amp;action=add\">New entry</a>"

  footer()
}


function addedit(      x, n, i, j, sel) {
  # version history: this is original version

  if (f["action"] == "edit")
    header("Editing " Tlabel[f["table"]] ", record " f["id"])
  else if (f["action"] == "add")
    header("New " Tlabel[f["table"]])
  else defaultpage()

  navbar()
  
  if (f["action"] == "edit") 
    print "<h1>Editing " Tlabel[f["table"]] ", record " f["id"] "</h1>"
  else if (f["action"] == "add")
    print "<h1>New " Tlabel[f["table"]] " record</h1>"

  make_lookup()
    
  print "<form action=\"do\">"
  print "<input type=\"hidden\" name=\"table\" value=\"" f["table"] "\"/>"
  print "<input type=\"hidden\" name=\"action\" value=\"show\"/>"
  print "<input type=\"hidden\" name=\"preaction\" value=\"" f["action"] "\"/>"

  if (f["action"] == "edit") {
    print "<input type=\"hidden\" name=\"id\" value=\"" f["id"] "\"/>"
    db_query(DATABASE, "SELECT * FROM `" f["table"] "` WHERE id = " f["id"] ";")
  }

  print "<table>"
  for (i = 1; i <= length(Forder[f["table"]]); i++) { 
    print "<tr>"
    print "<td align=\"right\">" Flabel[f["table"]][Forder[f["table"]][i]] \
      "</td>"
    # if a Foreign ID, create dropdown
    if (Fforid[f["table"]][Forder[f["table"]][i]]) {
      print "<td>"
      print "<select name=\"f-" Forder[f["table"]][i] "\" autocomplete=\"off\">"
      # See for firefox bug: https://stackoverflow.com/questions/4831848/
      #  firefox-ignores-option-selected-selected
      PROCINFO["sorted_in"] = "@val_str_asc"
      for (j in Lookup[ Fforid[f["table"]][Forder[f["table"]][i]] ]) {
        if (j == DBQ[1, Forder[f["table"]][i]])
          sel = " selected=\"selected\""
        else sel= ""
        print "<option value=\"" j "\"" sel ">"                            \
          Lookup[ Fforid[f["table"]][Forder[f["table"]][i]] ][j] "</option>"
      }
      PROCINFO["sorted_in"] = "@ind_str_asc"
      print "</select>"
      print "</td>"
    }
    else
      print "<td><input type=\"text\" name=\"f-" Forder[f["table"]][i]  \
        "\" size=\"30\" value=\"" DBQ[1, Forder[f["table"]][i]] "\"/></td>"
    print "</tr>"
  }
  print "</table>"
  print "<p><input type=\"submit\" value=\"GO\"/></p>"
  print "</form>"

  db_clear()
  footer()
}


function preaction(     sql, i, err) {
  if (f["preaction"] == "add") {
    sql = "INSERT INTO `" f["table"] "` ("
    for (i in f)
      if (substr(i,1,2) == "f-")
        sql = sql "`" substr(i,3) "`, "
    gsub(/, $/,"",sql)
    sql = sql ") VALUES ("
    for (i in f)
      if (substr(i,1,2) == "f-") {
        if (Ftype[f["table"]][substr(i,3)] == "c")
          sql = sql "'" f[i] "', "
        else
          sql = sql f[i] ", "
      }
    gsub(/, $/,"",sql)
    sql = sql ");"
    # print sql
  }
  
  if (f["preaction"] == "edit") {
    sql = "UPDATE `" f["table"] "` SET "
    for (i in f)
      if (substr(i,1,2) == "f-") {
        sql = sql "`" substr(i,3) "` = "
        if (Ftype[f["table"]][substr(i,3)] == "c")
          sql = sql "'" f[i] "', "
        else
          sql = sql f[i] ", "
      }
    gsub(/, $/,"",sql)
    sql = sql " WHERE `id` = " f["id"] " ;"
    # print sql
  }
  else if (f["preaction"] == "delete")
    sql = "DELETE FROM`" f["table"] "` WHERE id = " f["id"] ";"

  err = db_sql(DATABASE, sql)
  if (err)
    print "<p style=\"color:red;\">FAILED: " err "</p>"
  else print "<p style=\"color:green;\">Success</p>"
}


function navbar(  i, str) {
  str = "<div class=\"navbar\">"
  str = str "<a href=\"do\">Home</a>&#160;&#160;|&#160;&#160;"
  for (i in Tlabel)
    str = str "<a href=\"do?table=" i "&amp;action=show\">" Tlabel[i] \
      "</a>&#160;&#160;|&#160;&#160;"
  gsub(/&#160;&#160;\|&#160;&#160;$/,"",str)
  str = str "</div>"
  print str
}


# =========================== Database ============================

function db_query(db, query            , row, i, cmd, preFS ) {
  # version history: [awk-lib] -> [asriSMS] -> here

  gsub(/`/,"\\`", query)  # if writing directly in awk script, need: \\\`
  gsub(/\n/," ", query)
  gsub(/  */," ", query)
  cmd = "/bin/echo -e \"" query "\" | mysql -u " DBUSER[db] " -p" \
    DBPASSWORD[db] " -h " DBHOST[db] \
    " -B --column-names --default-character-set=utf8 " DBNAME[db] 
  row = -1
  preFS = FS
  FS = "\t"
  while ((cmd | getline ) > 0) {
    row++
    if (row == 0) {
      DBQc = NF
      for (i = 1; i <= NF; i++) DBQf[i] = $i
    }
    else {
      for (i = 1; i <= NF; i++) {
        gsub(/NULL/,"",$i)
        DBQ[row, DBQf[i]] = $i
      }
    }
  }
  close(cmd)
  # In the case of Empty Set
  if (row == -1) row = 0
  DBQr = row
  FS = preFS
}

function db_clear() {

  delete DBQ
  delete DBQf
  DBQr = 0
  DBQc = 0
}

function db_sql(db, query            , cmd, inRS, mysqlout ) {
  # version 2; history: [awk-lib] -> [asriSMS] -> here

  gsub(/\n/," ",query)
  gsub(/  */," ",query)
  inRS = RS
  RS = "\x04"
  cmd = "mysql -u " DBUSER[db]                              \
    " -p" DBPASSWORD[db] " -h " DBHOST[db] " " DBNAME[db] " 2>&1"
  # not using system(). This way allows v long SQL statements
  # system() returns mysql exit code. Here, we send stderr to stdout
  print query |& cmd
  close(cmd, "to")
  cmd |& getline mysqlout
  close(cmd,"from")
  RS = inRS
  return mysqlout

  # # check the db is accessible
  # e = db_sql("asrisms1", "SELECT '  OK' AS 'testing DB connection...';")
  # if (e)
  #   error("Database not accessible")
}


# =========================== Util ================================

function config(    t, t2, ta, fld, fa,     i, j, forderx) {
  # Config:
  #   table1 { table_atts { table, full_name, sort_field, foreign_show } /
  #   fields { field1 { fieldname, full_name, ci, sort_order , foreign_id? } ;
  #           field2 ; ... | table2 | ...

  gsub(/ /,"",Config)
  gsub(/_/," ",Config)

  # split into tables
  split(Config, t, "|")
  for (i in t) {

    # split into table atts and fields
    split(t[i],t2,"/")

    # table atts
    split(t2[1] ,ta,",")
    Tlabel[ta[1]]   = ta[2]
    Tsort[ta[1]]    = ta[3]
    Tforshow[ta[1]] = ta[4]
    gsub(/%5F/,"_",Tforshow[ta[1]])
    gsub(/%2C/,",",Tforshow[ta[1]])

    # fields
    split(t2[2], fld, ";")
    for (j in fld) {
      split(fld[j], fa, ",")
      Flabel[ ta[1]][fa[1]]  = fa[2]
      Ftype[  ta[1]][fa[1]]  = fa[3] # c (char) or i (int)
      forderx[ta[1]][fa[1]]  = fa[4] # 1...n ; if 0, do not print
      Fforid[ ta[1]][fa[1]]  = fa[5] # 
    }
    # swap forderx to Forder
    for (j in forderx[ta[1]])
      if (forderx[ta[1]][j])
        Forder[ta[1]][forderx[ta[1]][j]] = j
  }
}

function clean_quotes(   i) {
   # clean text input in case of attempt to insert as SQL
   for (i in f) {
     gsub(/'/,"\\'", f[i])
     gsub(/"/,"\\\"",f[i])
   }
}


function make_lookup(       i, j, sql) {
    # make lookups
  for (i = 1; i <= length(Forder[f["table"]]); i++)
    if (Fforid[f["table"]][Forder[f["table"]][i]]) {
      sql = "SELECT id, "                                   \
        Tforshow[Fforid[f["table"]][Forder[f["table"]][i]]] \
        " AS `_lookup` FROM `"                              \
        Fforid[f["table"]][Forder[f["table"]][i]] "`;"
      # print sql
      db_query(DATABASE, sql)
      for (j = 1; j <= DBQr; j++) {
        Lookup[Fforid[f["table"]][Forder[f["table"]][i]]][DBQ[j,"id"]] = \
          DBQ[j, "_lookup"]
      }
      db_clear()
    }

  # for (i in Lookup)
  #   for (j in Lookup[i])
  #     print i, j, Lookup[i][j]
}


function urldecode(text,   hex, i, hextab, decoded, len, c, c1, c2, code) {
# decode urlencoded string
# urldecode function from Heiner Steven
#   http://www.shelldorado.com/scripts/cmds/urldecode
# version 1
	
  split("0 1 2 3 4 5 6 7 8 9 a b c d e f", hex, " ")
  for (i=0; i<16; i++) hextab[hex[i+1]] = i
  
  decoded = ""
  i = 1
  len = length(text)
  
  while ( i <= len ) {
    c = substr (text, i, 1)
    if ( c == "%" ) {
      if ( i+2 <= len ) {
        c1 = tolower(substr(text, i+1, 1))
        c2 = tolower(substr(text, i+2, 1))
        if ( hextab [c1] != "" || hextab [c2] != "" ) {
          # print "Read: %" c1 c2;
          # Allow: 
          # 20 begins main chars, but dissallow 7F (wrong in orig code!)
          #   tab, newline, formfeed, carriage return
          if ( ( (c1 >= 2) && ((c1 c2) != "7f") )   \
               || (c1 == 0 && c2 ~ "[9acd]") )
            {
              code = 0 + hextab [c1] * 16 + hextab [c2] + 0
              # print "Code: " code
              c = sprintf ("%c", code)
            } else {
            # for dissallowed chars
            c = " "
          }
          i = i + 2
        }
      }
    } else if ( c == "+" ) 	# special handling: "+" means " "
      c = " "
    decoded = decoded c
    ++i
  }
  
  # change linebreaks to \n
  gsub(/\r\n/, "\n", decoded);
  # remove last linebreak
  sub(/[\n\r]*$/,"",decoded);
  return decoded
}

